<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cSPIKE v 1.0 29.9.2016: Eero Satuvuori</title>
   <meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-10-05"><meta name="DC.source" content="SpikeTrainSet.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>cSPIKE v 1.0 29.9.2016: Eero Satuvuori</h1><!--introduction--><p>This
is the main part of the cSPIKE. The object offers the basic
functionality of graphical user interface SPIKY as a command line
version. The main functions are implemented with MEX files and C++
backends. Methods are based on the ISI-distance, the SPIKE-distance and
the SPIKE-synchronization by Thomas Kreuz et al. The class contains
data and methods for storing spike trains as a single set as well as
calculating the different distance measures.</p><pre class="language-matlab">To <span class="string">use</span> <span class="string">SpikeTrainSet</span> <span class="string">you</span> <span class="string">need</span> <span class="string">a</span> <span class="string">C++</span> <span class="string">compiler</span> <span class="string">for</span> <span class="string">your</span> <span class="string">Matlab.</span> <span class="string">Some</span> <span class="string">help</span>
can <span class="string">be</span> <span class="string">found</span> <span class="string">in</span> <span class="string">the</span> <span class="string">following</span> <span class="string">links</span>
https://it.mathworks.com/help/matlab/matlab_external/what-you-need-to-build-mex-files.html
https://it.mathworks.com/support/compilers/R2016a/
</pre><pre class="language-matlab">SpikeTrainSet <span class="string">objects</span> <span class="string">can</span> <span class="string">be</span> <span class="string">created</span> <span class="string">without</span> <span class="string">compiling</span> <span class="string">MEX</span> <span class="string">files</span>, but<br>you <span class="untermstring">can't call any distance measures without the appropriate MEX</span>
compiled.
</pre><pre class="language-matlab">*** Important ***<br>Before <span class="string">you</span> <span class="string">use</span> <span class="string">the</span> <span class="string">cSPIKE</span> <span class="string">for</span> <span class="string">the</span> <span class="string">very</span> <span class="string">first</span> <span class="string">time</span> <span class="string">on</span> <span class="string">a</span> <span class="string">computer</span> <span class="string">you</span>
need <span class="string">to</span> <span class="string">compile</span> <span class="string">the</span> <span class="string">MEX</span> <span class="string">and</span> <span class="string">C++</span> <span class="string">backends.</span> <span class="string">To</span> <span class="string">do</span> <span class="string">so</span> <span class="string">go</span> <span class="string">to</span> <span class="string">folder</span>
cSPIKEmex <span class="string">and</span> <span class="string">run</span> <span class="string">script</span> <span class="string">MEX_compile.m.</span> <span class="string">This</span> <span class="string">may</span> <span class="string">take</span> <span class="string">few</span> <span class="string">minutes.</span>
</pre><pre class="language-matlab">Every <span class="string">time</span> <span class="string">you</span> <span class="string">call</span> <span class="string">for</span> <span class="string">MEX</span> <span class="string">files(most functions of the SpikeTrainSet</span>
use <span class="string">them) the folder in which they are located need to be in your</span>
Matlab <span class="string">workspace.</span> <span class="string">InitializecSPIKE-script</span> <span class="string">will</span> <span class="string">add</span> <span class="string">it</span> <span class="string">to</span> <span class="string">your</span> <span class="string">path.</span> <span class="string">It</span>
needs <span class="string">to</span> <span class="string">be</span> <span class="string">called</span> <span class="string">once</span> <span class="string">every</span> <span class="string">time</span> <span class="string">after</span> <span class="string">starting</span> <span class="string">Matlab</span> <span class="string">and</span> <span class="string">any</span>
additional <span class="string">calls</span> <span class="string">are</span> <span class="string">not</span> <span class="string">needed.</span> <span class="string">This</span> <span class="string">is</span> <span class="string">not</span> <span class="string">called</span> <span class="string">by</span> <span class="string">the</span> <span class="string">SpikeTrainSet!</span>
*****************
</pre><pre class="language-matlab">The <span class="string">SpikeTrainSet</span> <span class="string">implements</span> <span class="string">the</span> <span class="string">following</span> <span class="string">functions</span>
</pre><pre class="language-matlab">To <span class="string">create</span> <span class="string">a</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">set</span> <span class="string">object</span> <span class="string">call</span> <span class="string">the</span> <span class="string">constructor:</span>
</pre><pre class="language-matlab">spiketrains: A cell <span class="string">array</span> <span class="string">with</span> <span class="string">SpikeTrains{1}</span> <span class="string">containing</span> <span class="string">an</span>
             array <span class="string">of</span> <span class="string">spike</span> <span class="string">times</span> <span class="string">[spike1 spike2 </span><span class="keyword">...</span><span class="comment">spikeN] for the</span>
             <span class="string">first</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">and</span> <span class="string">respectively</span> <span class="string">for</span> <span class="string">the</span> <span class="string">other</span> <span class="string">spike</span>
             trains. The object <span class="string">accepts</span> <span class="string">only</span> <span class="string">spike</span> <span class="string">data</span> <span class="string">aligned</span> <span class="string">as</span> <span class="string">row</span>
             vectors
beginning: The start <span class="string">time</span> <span class="string">of</span> <span class="string">the</span> <span class="string">recording</span>
endgin: The <span class="keyword">end</span> time <span class="string">of</span> <span class="string">the</span> <span class="string">recording</span>
</pre><pre class="language-matlab">STS = SpikeTrainSet(spiketrains, beginning, ending )<br></pre><pre class="language-matlab">Then <span class="string">you</span> <span class="string">can</span> <span class="string">call</span> <span class="string">methods</span> <span class="string">for</span> <span class="string">the</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">set:</span>
</pre><pre class="language-matlab">time1: Start time <span class="string">of</span> <span class="string">the</span> <span class="string">analysis</span> <span class="string">interval.</span>
time2: End time <span class="string">of</span> <span class="string">the</span> <span class="string">analysis</span> <span class="string">interval.</span> <span class="string">If</span> <span class="string">not</span> <span class="string">given</span> <span class="string">or</span> <span class="string">if</span>
       time1 = time2 instantaneous <span class="string">dissimilarity</span> <span class="string">value</span> <span class="string">is</span> <span class="string">given</span> <span class="string">instead.</span>
threshold: Threshold <span class="keyword">for</span> the adaptive <span class="string">method.</span> <span class="string">If</span> <span class="string">not</span> <span class="string">given</span> <span class="string">the</span>
           threshold <span class="string">extracted</span> <span class="string">from</span> <span class="string">the</span> <span class="string">data</span> <span class="string">is</span> <span class="string">used</span> <span class="string">instead.</span>
Profile: Profile object
</pre><pre class="language-matlab">STS.ISIdistance(time1, time2)<br>STS.ISIdistanceMatrix(time1, time2)<br>Profile = STS.ISIdistanceProfile(time1, time2)<br></pre><pre class="language-matlab">STS.AdaptiveISIdistance(time1, time2, threshold)<br>STS.AdaptiveISIdistanceMatrix(time1, time2,threshold)<br>Profile = STS.AdaptiveISIdistanceProfile(time1, time2,threshold)<br></pre><pre class="language-matlab">STS.SPIKEdistance(time1, time2)<br>STS.SPIKEdistanceMatrix(obj, time1, time2)<br>Profile = STS.SPIKEdistanceProfile(obj, time1, time2)<br></pre><pre class="language-matlab">STS.AdaptiveSPIKEdistance(time1, time2, threshold)<br>STS.AdaptiveSPIKEdistanceMatrix(obj, time1, time2,threshold)<br>Profile = STS.AdaptiveSPIKEdistanceProfile(obj, time1, time2,threshold)<br></pre><pre class="language-matlab">STS.RateIndependentSPIKEdistance(time1, time2)<br>STS.AdaptiveRateIndependentSPIKEdistance(time1, time2, threshold)<br></pre><pre class="language-matlab">STS.SPIKEsynchro(time1,time2)<br></pre><pre class="language-matlab">STS.AdaptiveSPIKEsynchro(time1,time2,threshold)<br></pre><pre class="language-matlab">SPIKESM: Spike synchronization <span class="string">matrix</span>
SPIKEOM: Spike order <span class="string">matrix</span>
normSPIKEOM: normalized spike <span class="string">order</span> <span class="string">matrix</span>
</pre><pre class="language-matlab">[SPIKESM,SPIKEOM,normSPIKEOM]= STS.SPIKESynchroMatrix(time1, time2)<br>[SPIKESM,SPIKEOM,normSPIKEOM] = STS.AdaptiveSPIKESynchroMatrix(time1, time2, threshold)<br></pre><pre class="language-matlab">synchro: a cell <span class="string">array</span> <span class="string">identical</span> <span class="string">to</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">set</span> <span class="string">but</span> <span class="string">instead</span> <span class="string">of</span> <span class="string">spike</span>
         times <span class="string">it</span> <span class="string">contains</span> <span class="string">SPIKE-synchronization</span> <span class="string">values</span> <span class="string">of</span> <span class="string">each</span> <span class="string">spike</span>
Sorder: a cell <span class="string">array</span> <span class="string">identical</span> <span class="string">to</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">set</span> <span class="string">but</span> <span class="string">instead</span> <span class="string">of</span> <span class="string">spike</span>
        times <span class="string">it</span> <span class="string">contains</span> <span class="string">SPIKE-order</span> <span class="string">values</span> <span class="string">of</span> <span class="string">each</span> <span class="string">spike</span>
STOrder: a cell <span class="string">array</span> <span class="string">identical</span> <span class="string">to</span> <span class="string">spike</span> <span class="string">train</span> <span class="string">set</span> <span class="string">but</span> <span class="string">instead</span> <span class="string">of</span> <span class="string">spike</span>
         times <span class="string">it</span> <span class="string">contains</span> <span class="string">spike-train-order</span> <span class="string">values</span> <span class="string">of</span> <span class="string">each</span> <span class="string">spike</span>
</pre><pre class="language-matlab">[synchro,Sorder,STOrder] = STS.SPIKEsynchroProfile(time1, time2)<br>[synchro,Sorder,STOrder] = STS.AdaptiveSPIKEsynchroProfile(time1, time2,threshold)<br></pre><pre class="language-matlab">varargin: Each time <span class="string">moment</span> <span class="string">is</span> <span class="string">given</span> <span class="string">as</span> <span class="string">a</span> <span class="string">separate</span> <span class="string">parameter.</span> <span class="string">Returns</span>
          the <span class="string">dissimilarity</span> <span class="string">averaged</span> <span class="string">over</span> <span class="string">all</span> <span class="string">time</span> <span class="string">points.</span>
</pre><pre class="language-matlab">STS.TriggeredISImatrix(varargin)<br>STS.TriggeredAdaptiveISImatrix(threshold, varargin)<br>STS.TriggeredSPIKEmatrix(varargin)<br>STS.TriggeredAdaptiveSPIKEmatrix(threshold, varargin)<br></pre><pre class="language-matlab">varargin: Each pair <span class="string">of</span> <span class="string">inputs</span> <span class="string">defines</span> <span class="string">a</span> <span class="string">new</span> <span class="string">interval</span> <span class="string">over</span> <span class="string">which</span> <span class="string">the</span>
          distance <span class="string">is</span> <span class="string">defined.</span> <span class="string">A</span> <span class="string">unique</span> <span class="string">union</span> <span class="string">of</span> <span class="string">the</span> <span class="string">intervals</span> <span class="string">is</span>
          used <span class="string">when</span> <span class="string">defining</span> <span class="string">the</span> <span class="string">intervals</span> <span class="string">over</span> <span class="string">which</span> <span class="string">the</span> <span class="string">average</span> <span class="string">is</span>
          taken.
</pre><pre class="language-matlab">STS.AveragedISIdistanceMatrix(varargin)<br>STS.AveragedAdaptiveISIdistanceMatrix(threshold, varargin)<br>STS.AveragedSPIKEdistanceMatrix(varargin)<br>STS.AveragedAdaptiveSPIKEdistanceMatrix(threshold, varargin)<br></pre><pre class="language-matlab">Auxiliary <span class="string">functions:</span>
STS.SetData(spiketrains, beginning, ending )
    Replaces <span class="string">the</span> <span class="string">data</span> <span class="string">in</span> <span class="string">the</span> <span class="string">object</span> <span class="string">with</span> <span class="string">new</span> <span class="string">data</span>
STS.giveDATA()
    Gives <span class="string">the</span> <span class="string">a</span> <span class="string">copy</span> <span class="string">of</span> <span class="string">the</span> <span class="string">data</span> <span class="string">array</span> <span class="string">of</span> <span class="string">the</span> <span class="string">object.</span> <span class="string">Data{1}</span> <span class="string">contains</span>
    the <span class="string">edge</span> <span class="string">corrected</span> <span class="string">data</span> <span class="string">and</span> <span class="string">Data{2}</span> <span class="string">the</span> <span class="string">original</span> <span class="string">spikes.</span>
STS.giveTHR()
    Returns <span class="string">the</span> <span class="string">threshold</span> <span class="string">value</span> <span class="string">obtained</span> <span class="string">from</span> <span class="string">the</span> <span class="string">set</span>
[time1,time2] = STS.giveTIMES()
    Gives <span class="string">the</span> <span class="string">beginning</span> <span class="string">and</span> <span class="string">the</span> <span class="string">end</span> <span class="string">of</span> <span class="string">the</span> <span class="string">recording</span>
STS.plotSpikeTrainSet(colour,widith)
    Plots <span class="string">the</span> <span class="string">spike</span> <span class="string">trains</span> <span class="string">to</span> <span class="string">current</span> <span class="string">axis</span> <span class="string">with</span> <span class="string">colour</span> <span class="string">and</span> <span class="string">spike</span> <span class="string">widith</span>
    given. Default colour <span class="string">is</span> <span class="string">black.</span>
</pre><p>BSD license:</p><p>Copyright (c) 2016, Eero Satuvuori All rights reserved.</p><p>Redistribution
and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met: *
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer. * Redistributions
in binary form must reproduce the above copyright notice, this list of
conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution. * Neither the name of
the author nor the names of its contributors may be used to endorse or
promote products derived from this software without specific prior
written permission.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
NO EVENT SHALL <a href="COPYRIGHT">HOLDER</a> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Class for enclosing spiketrains into one class and handling the set.</a></li><li><a href="#3">PRIVATE METHODS **************************************************</a></li><li><a href="#5">Checking data availability</a></li><li><a href="#6">Unique Union</a></li><li><a href="#7">Checking that the DATA given is valid</a></li><li><a href="#8">Cutting function</a></li><li><a href="#10">Check input times</a></li><li><a href="#11">Correct the DATA Edges</a></li><li><a href="#12">Form pooled spiketrain of all spiketrains</a></li><li><a href="#13">Time shift functions.</a></li><li><a href="#15">PUBLIC METHODS ***************************************************</a></li><li><a href="#16">Constructor</a></li><li><a href="#17">Setting data</a></li><li><a href="#18">ISI METHODS ----------------------------------------------------</a></li><li><a href="#19">ISI-distance for interval/point</a></li><li><a href="#20">Adaptive ISI-distance for interval/point</a></li><li><a href="#21">ISI-distance/dissimilarity matrix</a></li><li><a href="#22">Adaptive ISI-distance/dissimilarity matrix</a></li><li><a href="#23">Triggered ISI-dissimilarity matrix</a></li><li><a href="#24">Triggered Adaptive ISI-dissimilarity matrix</a></li><li><a href="#25">Averaged ISI-distance matrix</a></li><li><a href="#26">Averaged Adaptive ISI-distance matrix</a></li><li><a href="#27">ISI-distance profile</a></li><li><a href="#28">Adaptive ISI-distance profile</a></li><li><a href="#29">SPIKE METHODS --------------------------------------------------</a></li><li><a href="#30">SPIKE-distance for interval/point</a></li><li><a href="#31">Adaptive SPIKE-distance for interval/point</a></li><li><a href="#32">Rate independent SPIKE distance for interval/point</a></li><li><a href="#33">Adaptive Rate independent SPIKE distance for interval/point</a></li><li><a href="#34">SPIKE distance/dissimilarity matrix</a></li><li><a href="#35">Adaptive SPIKE distance/dissimilarity matrix</a></li><li><a href="#36">Triggered SPIKE-dissimilarity matrix</a></li><li><a href="#37">Triggered Adaptive SPIKE-dissimilarity matrix</a></li><li><a href="#38">Averaged SPIKE-distance matrix</a></li><li><a href="#39">Averaged Adaptive SPIKE-distance matrix</a></li><li><a href="#40">SPIKE-distance profile</a></li><li><a href="#41">Adaptive SPIKE-distance profile</a></li><li><a href="#42">SPIKE-Synchronization METHODS ----------------------------------</a></li><li><a href="#43">SPIKE-Synchronization</a></li><li><a href="#44">Adaptive SPIKE-synchronization</a></li><li><a href="#45">SPIKE-synchronization profile</a></li><li><a href="#46">Adaptive SPIKE-synchronization profile</a></li><li><a href="#47">SPIKE-synchronization matrix</a></li><li><a href="#48">Adaptive SPIKE-synchronization matrix</a></li><li><a href="#49">Auxiliary functions --------------------------------------------</a></li><li><a href="#50">Get function</a></li><li><a href="#51">Threshold value extracted from the data</a></li><li><a href="#52">Start and end of the data set</a></li><li><a href="#53">Plotting function</a></li></ul></div><h2>Class for enclosing spiketrains into one class and handling the set.<a name="1"></a></h2><pre class="codeinput"><span class="keyword">classdef</span> SpikeTrainSet &lt; handle<br></pre><pre class="codeinput">    properties (Access = private)<br><br>        <span class="comment">% Internal datastores.</span>
        DataArray;
        PooledArray;
        timeStart;
        timeEnd;
        threshold;
        timeShift;
        realISIs;

        <span class="comment">% Internal accuracy used by the program. This is the maximum</span>
        <span class="comment">% accuracy used. Increasing the accuracy may lead to malfunctions.</span>
        accuracy = 10^-12;
    <span class="keyword">end</span>
</pre><h2>PRIVATE METHODS **************************************************<a name="3"></a></h2><pre class="codeinput">    methods (Access = private)<br></pre><h2>Checking data availability<a name="5"></a></h2><p>Function
is given a bool value if the information is crucial for the calling
function. In case it is an error is thrown. If it is not, just a bool
value of 0 is returned if there is no data yet.</p><pre class="codeinput">        <span class="keyword">function</span> bool = HaveData(obj, crucial)<br><br>            <span class="comment">% Returning 1 if there is data and 0 if there is not.</span>
            <span class="keyword">if</span> isempty(obj.DataArray)<br>                bool = 0;<br>                <span class="keyword">if</span> crucial<br>                    error(<span class="string">'No data available'</span>);<br>                <span class="keyword">end</span>
            <span class="keyword">else</span>
                bool = 1;
            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><h2>Unique Union<a name="6"></a></h2><p>Takes a set of intervals
as a cell array so that each pair of two values is an interval. The
output is a unique union of the intervals.</p><pre class="codeinput">        <span class="keyword">function</span> ReturnArray = UniqueUnion(obj, CellArray )<br>            starts = [];<br>            ends = [];<br>            <span class="keyword">for</span> i = 1:2:length(CellArray)<br>                starts(end+1) = CellArray{i};<br>                ends(end+1) = CellArray{i+1};<br>            <span class="keyword">end</span>

            UniqueArray = 0;

            <span class="keyword">while</span> ~UniqueArray<br>                moves = 0;<br>                <span class="comment">% Taking each first spike and if it is in an interval, move</span>
                <span class="comment">% it to the border of the interval.</span>
                <span class="keyword">for</span> i = 1:length(starts)<br>                    <span class="keyword">for</span> ii = 1:length(starts)<br><br>                        <span class="keyword">if</span> (i ~= ii)<br><br>                            <span class="keyword">if</span> (starts(i) &gt; starts(ii) &amp;&amp; starts(i)&lt; ends(ii))<br><br>                                starts(i) = starts(ii);<br>                                moves = moves + 1;<br>                            <span class="keyword">end</span>
                        <span class="keyword">end</span>

                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="comment">% Taking each last spike and doing the same.</span>
                <span class="keyword">for</span> i = 1:length(ends)<br>                    <span class="keyword">for</span> ii = 1:length(ends)<br><br>                        <span class="keyword">if</span> (i ~= ii)<br><br>                            <span class="keyword">if</span> (ends(i) &gt; starts(ii) &amp;&amp; ends(i) &lt; ends(ii))<br><br>                                ends(i) = ends(ii);<br>                                moves = moves + 1;<br>                            <span class="keyword">end</span>
                        <span class="keyword">end</span>

                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="comment">% If there were no moves this round, all the spikes are at</span>
                <span class="comment">% the edges of their intervals. There may be multiple same</span>
                <span class="comment">% intervals.</span>
                <span class="keyword">if</span> moves  == 0<br><br>                    <span class="comment">% now the array is unique. No need to continue.</span>
                    UniqueArray = 1;

                    <span class="comment">% Taking each interval only once.</span>
                    Ustarts = unique(starts);
                    Uends = unique(ends);

                    <span class="comment">% Since the intervals are in time order and unique,</span>
                    <span class="comment">% they will be in correct time order after unique</span>
                    <span class="comment">% command. The output is formed based on the intervals</span>
                    ReturnArray = cell(0);
                    <span class="keyword">for</span> i = 1:length(Ustarts)<br><br>                        ReturnArray{end+1} = Ustarts(i);<br>                        ReturnArray{end+1} = Uends(i);<br>                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Checking that the DATA given is valid<a name="7"></a></h2><p>Function checks the data and gives an error if the data is not in a correct form</p><pre class="codeinput">        <span class="keyword">function</span> CheckData(obj,Data)<br><br>            <span class="keyword">if</span> ~iscell(Data)<br>                error(<span class="string">'Data is not a cell array'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> length(Data) == 1<br>                error(<span class="string">'One spiketrain'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">for</span> i = 1:length(Data)<br><br>                <span class="keyword">if</span> ndims(Data)~=2 || size(Data,2) ~= 1;<br>                    error(<span class="string">'Data has incorrectly aligned cell array'</span>);<br>                <span class="keyword">end</span>

                <span class="keyword">if</span> ndims(Data{i}) ~=2 &amp;&amp; (size(Data{i},1)||size(Data{i},2))<br>                    error(<span class="string">'Data has too many dimensions'</span>);<br>                <span class="keyword">end</span>

                <span class="keyword">if</span> size(Data{i},1) ~= 1<br>                    <span class="keyword">if</span>  ~isempty(Data{i})<br>                        error(<span class="string">'Data has incorrectly aligned vectors'</span>);<br>                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="keyword">if</span> ~isnumeric(Data{i})<br>                    error(<span class="string">'Data is not all numeric'</span>);<br>                <span class="keyword">end</span>
            <span class="keyword">end</span>


        <span class="keyword">end</span>
</pre><h2>Cutting function<a name="8"></a></h2><p>This function cuts the data so that spikes outside of boundaries are removed.</p><pre class="codeinput">        <span class="keyword">function</span> Data = CutData(obj,Data, START, END)<br><br><br>            <span class="keyword">for</span> i = 1:length(Data)<br>                inds = not(abs(sign(sign(START-obj.accuracy - Data{i})<span class="keyword">...</span>
                       + sign(END+obj.accuracy - Data{i}))));
                Data{i} = Data{i}(inds);
            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> Data = RoundData(obj, Data)<br><br>            dt = obj.accuracy;<br>            <span class="keyword">for</span> i = 1:length(Data)<br>                Data{i} = round(Data{i}/dt)*dt;<br>            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><h2>Check input times<a name="10"></a></h2><p>Checking that times given are in correct order and within boundaries</p><pre class="codeinput">        <span class="keyword">function</span> CheckTime(obj,Time1,Time2)<br>            <span class="keyword">if</span> Time1  &gt; Time2<br>                error(<span class="string">'Time interval boundaries incorrect'</span>);<br>            <span class="keyword">end</span>

            <span class="keyword">if</span> ~((Time1 &gt;= obj.timeStart) &amp;&amp; (Time2 &lt;= obj.timeEnd))<br>                error(<span class="string">'time interval not within data bounds'</span>);<br>            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><h2>Correct the DATA Edges<a name="11"></a></h2><p>Adds edge correction and makes sure that there are only 1 spike at each time instant. Also rearranges the data into time series.</p><pre class="codeinput">        <span class="keyword">function</span> Corrected = EdgeCorrection(obj,Data,time1,time2)<br><br>            PooledISIs = [];<br>            Corrected = cell(1,length(Data))';<br>            <span class="keyword">for</span> i = 1:length(Data)<br>                <span class="comment">% 0 or 1 spikes cases</span>
                <span class="keyword">if</span> isempty(Data{i}) || length(Data{i}) == 1<br>                    <span class="keyword">if</span> isempty(Data{i})<br>                        first = -(time2-time1)*1.2;<br>                        last = (time2-time1)*2.2;<br>                        Corrected{i} = [first obj.timeStart obj.timeEnd last];<br>                        Corrected{i} = unique(Corrected{i});<br>                        thisST = obj.timeEnd-obj.timeStart;<br>                    <span class="keyword">else</span>
                        fullST = 0; <span class="comment">%flag</span>
                        first = obj.timeStart;
                        last = obj.timeEnd;
                        <span class="keyword">if</span> Data{i} == first<br>                            first = -(time2-time1)*1.2;<br>                            thisST = obj.timeEnd-obj.timeStart;<br>                            fullST = 1;<br>                        <span class="keyword">end</span>
                        <span class="keyword">if</span> Data{i} == last<br>                            last = (time2-time1)*2.2;<br>                            thisST = obj.timeEnd-obj.timeStart;<br>                            fullST = 1;<br>                        <span class="keyword">end</span>

                        <span class="keyword">if</span> ~fullST<br>                            thisST = [last-Data{i} Data{i}-first];<br>                        <span class="keyword">end</span>

                        Corrected{i} = [first Data{i} last];
                        Corrected{i} = unique(Corrected{i});
                    <span class="keyword">end</span>

                <span class="keyword">else</span>
                    <span class="comment">%The rest</span>
                    thisST = Data{i}(2:end) - Data{i}(1:end-1);
                    <span class="keyword">if</span>(Data{i}(1) ~= time1)<br>                        first = Data{i}(1) - max( Data{i}(2)-Data{i}(1), Data{i}(1) - obj.timeStart );<br>                        thisST = [thisST Data{i}(1)-first];<br>                    <span class="keyword">else</span>
                        <span class="comment">% In case the first spike is at the border it is</span>
                        <span class="comment">% not treated as auxiliary spike. For calculation</span>
                        <span class="comment">% the next spike does not matter so we add an</span>
                        <span class="comment">% "auxiliary" spike very far from the dataset to</span>
                        <span class="comment">% mark that the border is a real one.</span>
                        first = -(time2-time1)*1.2;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span>(Data{i}(end)~= time2)<br>                        last = Data{i}(end) + max( Data{i}(end)-Data{i}(end-1),obj.timeEnd - Data{i}(end));<br>                        thisST = [thisST last-Data{i}(end)];<br>                    <span class="keyword">else</span>
                        <span class="comment">% Same for the other end.</span>
                        last = (time2-time1)*2.2;
                    <span class="keyword">end</span>



                    Corrected{i} = [first last Data{i}];

                    <span class="comment">% At the end making sure that each dataset has only one</span>
                    <span class="comment">% spike at each time instant and that they are in time</span>
                    <span class="comment">% order</span>
                    Corrected{i} = unique(Corrected{i});
                <span class="keyword">end</span>
                PooledISIs = [PooledISIs thisST];
            <span class="keyword">end</span>

            <span class="keyword">if</span>(isempty (PooledISIs))<br>                obj.threshold = 0;<br>            <span class="keyword">else</span>
                obj.threshold = sqrt(mean(PooledISIs.^2));
            <span class="keyword">end</span>
            obj.realISIs = PooledISIs;

        <span class="keyword">end</span>
</pre><h2>Form pooled spiketrain of all spiketrains<a name="12"></a></h2><p>Pools all spiketrains into one. Uses unique, so that multiple spikes at same times are filtered out.</p><pre class="codeinput">        <span class="keyword">function</span> Pooled = Pool(obj , Data)<br><br>            Pooled = [];<br>            <span class="keyword">for</span> i = 1:length(Data)<br>                Pooled = [Pooled Data{i}];<br>            <span class="keyword">end</span>
            Pooled = unique(Pooled);

        <span class="keyword">end</span>
</pre><h2>Time shift functions.<a name="13"></a></h2><p>These functions
take care of the difference between "real" times and internal times.
The object computes using positive spiketimes and in case the recording
begins at negative times, all data is shifted so that the recording
begins from 0 internally. For output the times are again shifted back
to original.</p><pre class="codeinput">        <span class="keyword">function</span>  [time1,time2,Data] = CreateTimeShift(obj,time1,time2,Data)<br><br>            obj.timeShift = time1;<br>            time1 = time1-obj.timeShift;<br>            time2 = time2-obj.timeShift;<br>            <span class="keyword">for</span> i = 1:length(Data)<br>                Data{i}=Data{i}-obj.timeShift;<br>            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span>  [time] = InputTimeShift(obj,time)<br><br>            time = time-obj.timeShift;<br><br>        <span class="keyword">end</span>


        <span class="keyword">function</span>  [time] = outputTimeShift(obj,time)<br><br>            time = time+obj.timeShift;<br><br>        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><h2>PUBLIC METHODS ***************************************************<a name="15"></a></h2><pre class="codeinput">    methods (Access = public)<br></pre><h2>Constructor<a name="16"></a></h2><p>Builds a spiketrain set with the spiketrains given and beginning and end times.</p><pre class="codeinput">        <span class="keyword">function</span> obj = SpikeTrainSet(spiketrains, beginning, ending )<br>            obj.timeShift = 0;<br>            obj.SetData(spiketrains, beginning, ending );<br><br>        <span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.<br><br>Error in SpikeTrainSet (line 471)<br>            obj.SetData(spiketrains, beginning, ending );<br></pre><h2>Setting data<a name="17"></a></h2><p>Function
sets data to the classes own variables. Calls appropriate checking
functions to input. Data is only accepted in a single cell array
containing spiketrains. If called to a spiketrain set that has already
been set, the user is asked for input if it is to be replaced.</p><pre class="codeinput">        <span class="keyword">function</span> SetData(obj, Data, time1, time2)<br>            Data = Data';<br>            <span class="comment">% checking that the data is in correct form.</span>
            obj.CheckData(Data);
            <span class="comment">%Rounding data to 12 digits accuracy</span>
            Data = obj.RoundData(Data);
            <span class="comment">% Cutting spikes outside of interval</span>
            Data = obj.CutData(Data, time1, time2);
            <span class="comment">% If there was no data, add the data</span>
            <span class="keyword">if</span> obj.HaveData(0)<br><br>                <span class="comment">%presetting answer variable into not n or y</span>
                answer = <span class="string">'h'</span>;<br>                <span class="comment">% If there was data, ask if the data is to be replaced</span>
                <span class="keyword">while</span> answer ~= <span class="string">'y'</span> &amp;&amp; answer ~= <span class="string">'Y'</span> &amp;&amp; answer ~= <span class="string">'n'</span> &amp;&amp; answer ~= <span class="string">'N'</span>
                    answer = input(<span class="string">'Do you want to replace the data?(y/n)'</span>,<span class="string">'s'</span>);<br>                <span class="keyword">end</span>
                <span class="comment">%</span>
                <span class="keyword">if</span> answer == <span class="string">'y'</span> || answer ~= <span class="string">'Y'</span>

                    <span class="comment">% Swiping old arrays clean</span>
                    obj.DataArray = [];
                    obj.PooledArray= [];

                    <span class="comment">% Adding new values to the array</span>
                    obj.DataArray{2} = Data;
                    [time1,time2,Data] = obj.CreateTimeShift(time1,time2,Data);
                    obj.timeStart = time1;
                    obj.timeEnd = time2;
                    obj.DataArray{1} = obj.EdgeCorrection(Data);
                    obj.PooledArray = obj.Pool(Data);

                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="comment">% Setting the arrays for the first time</span>
                obj.DataArray{2} = Data;
                [time1,time2,Data] = obj.CreateTimeShift(time1,time2,Data);
                obj.timeStart = time1;
                obj.timeEnd = time2;
                obj.DataArray{1} = obj.EdgeCorrection(Data,time1,time2);
                obj.PooledArray = obj.Pool(Data);

            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><h2>ISI METHODS ----------------------------------------------------<a name="18"></a></h2><p>The methods in this section are applying ISI distance measure to the data. The section also contains Adaptive extension.</p><h2>ISI-distance for interval/point<a name="19"></a></h2><p>Calculates
ISI distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, return dissimilarity of the spiketrains at that time instant.</p><pre class="codeinput">        <span class="keyword">function</span>  ISId = ISIdistance(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            ISId = AdaptiveISIdistance(obj, time1, time2, 0);

        <span class="keyword">end</span>
</pre><h2>Adaptive ISI-distance for interval/point<a name="20"></a></h2><p>Calculates
SPIKE distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, return dissimilarity of the spiketrains at that time instant.</p><pre class="codeinput">        <span class="keyword">function</span>  ISId = AdaptiveISIdistance(obj, time1, time2, threshold)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            <span class="keyword">if</span>(time1 == time2)<br>                ISId = mexAdaptiveISIDistance(obj.DataArray{1},threshold,time1);<br>            <span class="keyword">else</span>
                ISId = mexAdaptiveISIDistance(obj.DataArray{1},threshold,time1, time2);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>ISI-distance/dissimilarity matrix<a name="21"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time interval
defined by time 1 and time 2. If not given, averaged over whole
interval. If given only one time or the same one twice, the returned
matrix is dissimilarity between all pairs.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = ISIdistanceMatrix(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            ISIdM = AdaptiveISIdistanceMatrix(obj, time1, time2, 0);
        <span class="keyword">end</span>
</pre><h2>Adaptive ISI-distance/dissimilarity matrix<a name="22"></a></h2><p>Returns
the adaptive distance matrix of the spike trains averaged over time
interval defined by time 1 and time 2. If not given, averaged over
whole interval. If given only one time or the same one twice, the
returned matrix is dissimilarity between all pairs. Threshold can be
given as a parameter. If not given the one extracted from the data is
used.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = AdaptiveISIdistanceMatrix(obj, time1, time2,threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            ISIdM = mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold ,time1, time2);

        <span class="keyword">end</span>
</pre><h2>Triggered ISI-dissimilarity matrix<a name="23"></a></h2><p>Returns
the averaged dissimilarity matrix of the spike trains averaged over
time instants defined in inputs. Each instant is given as new
variables: (1,2,5,6) being average over time instants 1,2,5 and 6.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = TriggeredISImatrix(obj, varargin)<br><br>            <span class="keyword">if</span> nargin &lt; 3<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            ISIdM = TriggeredAdaptiveISImatrix(obj,0, varargin);
        <span class="keyword">end</span>
</pre><h2>Triggered Adaptive ISI-dissimilarity matrix<a name="24"></a></h2><p>Returns
the averaged dissimilarity matrix of the spike trains averaged over
time instants defined in inputs. Each instant is given as new
variables: (1,2,5,6) being average over time instants 1,2,5 and 6. If a
negative threshold value is given the data exctracted threshold is used.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = TriggeredAdaptiveISImatrix(obj,threshold, varargin)<br>            <span class="keyword">if</span> threshold &lt; 0<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>

            obj.HaveData(1);
            time = obj.InputTimeShift(varargin{1});
            obj.CheckTime(time,time);

            ISIdM = mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold,time, time);
            <span class="keyword">for</span> i = 2:(nargin-1)<br>                time = obj.InputTimeShift(varargin{i});<br>                obj.CheckTime(time,time);<br>                ISIdM = ISIdM + mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold,time, time);<br>            <span class="keyword">end</span>

            ISIdM = ISIdM./(nargin-2);
        <span class="keyword">end</span>
</pre><h2>Averaged ISI-distance matrix<a name="25"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time intervals
defined as pairs of inputs. The inputs must be in pairs. If the
intervals overlap, the average is computed over unique union of the
intervals. Input is given as new pairs of variables: (1,2,5,6) being
average over time intervals [1,2] and [5,6].</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = AveragedISIdistanceMatrix(obj, varargin)<br>            <span class="keyword">if</span> nargin &lt; 3<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> mod(nargin,2) == 0;<br>                error(<span class="string">'Not a paired number of time points'</span>);<br>            <span class="keyword">end</span>

            ISIdM = AveragedAdaptiveISIdistanceMatrix(obj,0, varargin);

        <span class="keyword">end</span>
</pre><h2>Averaged Adaptive ISI-distance matrix<a name="26"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time intervals
defined as pairs of inputs. The inputs must be in pairs. If the
intervals overlap, the average is computed over unique union of the
intervals. Input is given as new pairs of variables: (1,2,5,6) being
average over time intervals [1,2] and [5,6]. Threshold can be given as
a parameter. If a negative threshold value is given the data exctracted
threshold is used.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIdM = AveragedAdaptiveISIdistanceMatrix(obj,threshold, varargin)<br>            <span class="keyword">if</span> threshold &lt; 0<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> mod(nargin,2) == 1;<br>                error(<span class="string">'Not a paired number of time points'</span>);<br>            <span class="keyword">end</span>

            obj.HaveData(1);

            <span class="comment">% Forming unique union of input</span>
            Timeslices = obj.UniqueUnion(varargin);

            time1 = Timeslices{1};
            time2 = Timeslices{2};
            time1 = obj.InputTimeShift(time1);
            time2 = obj.InputTimeShift(time2);
            obj.CheckTime(time1,time2);
            TotalTime = time2-time1;
            ISIdM = (time2-time1)*mexISIistanceMatrix(obj.DataArray{1},threshold,time1, time2);

            <span class="keyword">for</span> i = 3:2:length(Timeslices)<br><br>                time1 = Timeslices{i};<br>                time2 = Timeslices{i+1};<br>                time1 = obj.InputTimeShift(time1);<br>                time2 = obj.InputTimeShift(time2);<br>                obj.CheckTime(time1,time2);<br>                ISIdM = ISIdM + (time2-time1)*mexISIistanceMatrix(obj.DataArray{1},threshold,time1, time2);<br>                TotalTime = TotalTime + (time2-time1);<br>            <span class="keyword">end</span>

            <span class="comment">% averaging over time. Each matrix is weighted</span>
            ISIdM = ISIdM./TotalTime;
        <span class="keyword">end</span>
</pre><h2>ISI-distance profile<a name="27"></a></h2><p>Forms a profile
between times 1 and 2. The output is a Matlab class Profile, which
contains the profile and can even perform a simple plotting. See object
Profile for more information.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIp = ISIdistanceProfile(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            ISIp = AdaptiveISIdistanceProfile(obj, time1, time2,0);
        <span class="keyword">end</span>
</pre><h2>Adaptive ISI-distance profile<a name="28"></a></h2><p>Forms a
profile between times 1 and 2. The output is a Matlab class Profile,
which contains the profile and can even perform a simple plotting. See
object Profile for more information.</p><pre class="codeinput">        <span class="keyword">function</span>  ISIp = AdaptiveISIdistanceProfile(obj, time1, time2,threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            internalProfile = mexAdaptiveISIDistanceProfile(obj.DataArray{1},threshold,time1, time2);
            internalProfile(2,:) = obj.outputTimeShift(internalProfile(2,:));
            ISIp = Profile(internalProfile);

        <span class="keyword">end</span>
</pre><h2>SPIKE METHODS --------------------------------------------------<a name="29"></a></h2><p>The
methods in this section are applying the SPIKE-distance measure to the
data. The section also contains Adaptive and rate intedependent
extensions.</p><h2>SPIKE-distance for interval/point<a name="30"></a></h2><p>Calculates
SPIKE distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, return dissimilarity of the spiketrains at that time instant.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEd = SPIKEdistance(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            SPIKEd = AdaptiveSPIKEdistance(obj, time1, time2, 0);
        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE-distance for interval/point<a name="31"></a></h2><p>Calculates
SPIKE distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, return dissimilarity of the spiketrains at that time instant.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEd = AdaptiveSPIKEdistance(obj, time1, time2, threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>

            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            <span class="keyword">if</span>(time1 == time2)<br>                SPIKEd = mexAdaptiveSPIKEDistance(obj.DataArray{1},threshold,time1);<br>            <span class="keyword">else</span>
                SPIKEd = mexAdaptiveSPIKEDistance(obj.DataArray{1},threshold,time1, time2);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Rate independent SPIKE distance for interval/point<a name="32"></a></h2><p>Calculates
SPIKE distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, returns dissimilarity of the spiketrains at that time instant.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEd = RateIndependentSPIKEdistance(obj, time1, time2)<br><br>            SPIKEd = AdaptiveRateIndependentSPIKEdistance(obj, time1, time2, 0);<br><br>        <span class="keyword">end</span>
</pre><h2>Adaptive Rate independent SPIKE distance for interval/point<a name="33"></a></h2><p>Calculates
SPIKE distance for given interval between time1 and time2. time1 &lt;
time2. If no input times are given return value for whole data set
interval that is defined. If only one time is given or both are the
same, returns dissimilarity of the spiketrains at that time instant.
This will use the predetermined threshold. If you then want to set
threshold yourself give it as third parameter.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEd = AdaptiveRateIndependentSPIKEdistance(obj, time1, time2, threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>

            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            <span class="keyword">if</span>(time1 == time2)<br>                SPIKEd = mexAdaptiveRateIndependentSPIKEDistance(obj.DataArray{1},threshold,time1);<br>            <span class="keyword">else</span>
                SPIKEd = mexAdaptiveRateIndependentSPIKEDistance(obj.DataArray{1},threshold,time1, time2);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>SPIKE distance/dissimilarity matrix<a name="34"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time interval
defined by time 1 and time 2. If not given, averaged over whole
interval. If given only one time or the same one twice, the returned
matrix is dissimilarity between all pairs.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = SPIKEdistanceMatrix(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            SPIKEdM = AdaptiveSPIKEdistanceMatrix(obj, time1, time2, 0);
        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE distance/dissimilarity matrix<a name="35"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time interval
defined by time 1 and time 2. If not given, averaged over whole
interval. If given only one time or the same one twice, the returned
matrix is dissimilarity between all pairs.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = AdaptiveSPIKEdistanceMatrix(obj, time1, time2,threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            SPIKEdM = mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);

        <span class="keyword">end</span>
</pre><h2>Triggered SPIKE-dissimilarity matrix<a name="36"></a></h2><p>Returns
the averaged dissimilarity matrix of the spike trains averaged over
time instants defined in inputs. Each instant is given as new
variables: (1,2,5,6) being average over time instants 1,2,5 and 6.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = TriggeredSPIKEmatrix(obj, varargin)<br><br>            <span class="keyword">if</span> nargin &lt; 3<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            SPIKEdM = TriggeredAdaptiveSPIKEmatrix(obj,0, varargin);

        <span class="keyword">end</span>
</pre><h2>Triggered Adaptive SPIKE-dissimilarity matrix<a name="37"></a></h2><p>Returns
the averaged dissimilarity matrix of the spike trains averaged over
time instants defined in inputs. Each instant is given as new
variables: (1,2,5,6) being average over time instants 1,2,5 and 6. If a
negative threshold value is given the data exctracted threshold is used.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = TriggeredAdaptiveSPIKEmatrix(obj,threshold, varargin)<br>            <span class="keyword">if</span> threshold &lt; 0<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>

            obj.HaveData(1);
            time = obj.InputTimeShift(varargin{1});
            obj.CheckTime(time,time);

            SPIKEdM = mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time, time);
            <span class="keyword">for</span> i = 2:(nargin-1)<br>                time = obj.InputTimeShift(varargin{i});<br>                obj.CheckTime(time,time);<br>                SPIKEdM = SPIKEdM + mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time, time);<br>            <span class="keyword">end</span>

            SPIKEdM = SPIKEdM./(nargin-1);
        <span class="keyword">end</span>
</pre><h2>Averaged SPIKE-distance matrix<a name="38"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time intervals
defined as pairs of inputs. The inputs must be in pairs. If the
intervals overlap, the average is computed over unique union of the
intervals. Input is given as new pairs of variables: (1,2,5,6) being
average over time intervals [1,2] and [5,6].</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = AveragedSPIKEdistanceMatrix(obj, varargin)<br><br>            <span class="keyword">if</span> nargin &lt; 3<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> mod(nargin,2) == 0;<br>                error(<span class="string">'Not a paired number of time points'</span>);<br>            <span class="keyword">end</span>
            SPIKEdM = AveragedAdaptiveSPIKEdistanceMatrix(obj, 0, varargin);
        <span class="keyword">end</span>
</pre><h2>Averaged Adaptive SPIKE-distance matrix<a name="39"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time intervals
defined as pairs of inputs. The inputs must be in pairs. If the
intervals overlap, the average is computed over unique union of the
intervals. Input is given as new pairs of variables: (1,2,5,6) being
average over time intervals [1,2] and [5,6]. Threshold can be given as
a parameter. If a negative threshold value is given the data exctracted
threshold is used.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEdM = AveragedAdaptiveSPIKEdistanceMatrix(obj, threshold, varargin)<br>            <span class="keyword">if</span> threshold &lt; 0<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                error(<span class="string">'Not enough input arguments'</span>);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> mod(nargin,2) == 1;<br>                error(<span class="string">'Not a paired number of time points'</span>);<br>            <span class="keyword">end</span>

            obj.HaveData(1);

            <span class="comment">% Forming unique union of input</span>
            Timeslices = obj.UniqueUnion(varargin);

            time1 = Timeslices{1};
            time2 = Timeslices{2};
            time1 = obj.InputTimeShift(time1);
            time2 = obj.InputTimeShift(time2);
            obj.CheckTime(time1,time2);
            TotalTime = time2-time1;
            SPIKEdM = (time2-time1)*mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);

            <span class="keyword">for</span> i = 3:2:length(Timeslices)<br><br>                time1 = Timeslices{i};<br>                time2 = Timeslices{i+1};<br>                time1 = obj.InputTimeShift(time1);<br>                time2 = obj.InputTimeShift(time2);<br>                obj.CheckTime(time1,time2);<br>                SPIKEdM = SPIKEdM + (time2-time1)*mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);<br>                TotalTime = TotalTime + (time2-time1);<br>            <span class="keyword">end</span>

            <span class="comment">% averaging over time. Each matrix is weighted</span>
            SPIKEdM = SPIKEdM./TotalTime;
        <span class="keyword">end</span>
</pre><h2>SPIKE-distance profile<a name="40"></a></h2><p>Forms a
profile between times 1 and 2. The output is a Matlab class Profile,
which contains the profile and can even perform a simple plotting.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEp = SPIKEdistanceProfile(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            SPIKEp = AdaptiveSPIKEdistanceProfile(obj, time1, time2, 0);

        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE-distance profile<a name="41"></a></h2><p>Forms
a profile between times 1 and 2. The output is a Matlab class Profile,
which contains the profile and can even perform a simple plotting.</p><pre class="codeinput">        <span class="keyword">function</span>  SPIKEp = AdaptiveSPIKEdistanceProfile(obj, time1, time2,threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            internalProfile = mexAdaptiveSPIKEDistanceProfile(obj.DataArray{1},threshold,time1, time2);
            internalProfile(2,:) = obj.outputTimeShift(internalProfile(2,:));
            SPIKEp = Profile(internalProfile);

        <span class="keyword">end</span>
</pre><h2>SPIKE-Synchronization METHODS ----------------------------------<a name="42"></a></h2><p>The methods in this section are applying SPIKE-synchronization measure to the data</p><h2>SPIKE-Synchronization<a name="43"></a></h2><p>This function returns the value of the method from the interval given in the input.</p><pre class="codeinput">        <span class="keyword">function</span>  synchro = SPIKEsynchro(obj,time1,time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            synchro = AdaptiveSPIKEsynchro(obj,time1,time2, 0);
        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE-synchronization<a name="44"></a></h2><p>This
function returns the value of the method from the interval given in the
input. If no threshold value is given the data exctracted value is used.</p><pre class="codeinput">        <span class="keyword">function</span>  synchro = AdaptiveSPIKEsynchro(obj,time1,time2,threshold)<br>            obj.HaveData(1);<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            synchro = mexAdaptiveSPIKESynchro(obj.DataArray{1},threshold/2,obj.timeStart,obj.timeEnd,time1,time2);

        <span class="keyword">end</span>
</pre><h2>SPIKE-synchronization profile<a name="45"></a></h2><p>Forms a
profile between times 1 and 2. The output is a Matlab class Profile,
which contains the profile and can even perform a simple plotting.</p><pre class="codeinput">        <span class="keyword">function</span>  [synchro, Sorder, STOrder] = SPIKEsynchroProfile(obj, time1, time2)<br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            [synchro, Sorder, STOrder] = AdaptiveSPIKEsynchroProfile(obj, time1, time2, 0);

        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE-synchronization profile<a name="46"></a></h2><p>Forms
a profile between times 1 and 2. The output is a Matlab class Profile,
which contains the profile and can even perform a simple plotting.</p><pre class="codeinput">        <span class="keyword">function</span>  [synchro, Sorder, STOrder] = AdaptiveSPIKEsynchroProfile(obj, time1, time2,threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>

            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            <span class="comment">% Change later into a real profile</span>
            [synchro, Sorder, STOrder] = mexAdaptiveSPIKESynchroProfile(obj.DataArray{1},threshold/2,obj.timeStart,obj.timeEnd,time1, time2);

        <span class="keyword">end</span>
</pre><h2>SPIKE-synchronization matrix<a name="47"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time interval
defined by time 1 and time 2. If not given, averaged over whole
interval. If given only one time or the same one twice, the returned
matrix is dissimilarity between all pairs.</p><pre class="codeinput">        <span class="keyword">function</span>  [SPIKESM,SPIKEOM,normSPIKEOM] = SPIKESynchroMatrix(obj, time1, time2)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = outputTimeShift(obj,obj.timeStart);<br>                time2 = outputTimeShift(obj,obj.timeEnd);<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>

            [SPIKESM,SPIKEOM,normSPIKEOM] = AdaptiveSPIKESynchroMatrix(obj, time1, time2, 0);

        <span class="keyword">end</span>
</pre><h2>Adaptive SPIKE-synchronization matrix<a name="48"></a></h2><p>Returns
the distance matrix of the spike trains averaged over time interval
defined by time 1 and time 2. If not given, averaged over whole
interval. If given only one time or the same one twice, the returned
matrix is dissimilarity between all pairs. If no threshold value is
given thedata exctracted value is used.</p><pre class="codeinput">        <span class="keyword">function</span>  [SPIKESM,SPIKEOM,normSPIKEOM] = AdaptiveSPIKESynchroMatrix(obj, time1, time2, threshold)<br><br>            <span class="keyword">if</span> nargin == 1<br>                time1 = obj.timeStart;<br>                time2 = obj.timeEnd;<br>            <span class="keyword">else</span>
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 2<br>                time2 = time1;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 4<br>                threshold = obj.threshold;<br>            <span class="keyword">end</span>
            obj.HaveData(1);
            obj.CheckTime(time1,time2);

            NroSpiketrains = length(obj.DataArray{1});
            SPIKESM = ones(NroSpiketrains);
            SPIKEOM = zeros(NroSpiketrains);
            normSPIKEOM = zeros(NroSpiketrains);
            <span class="keyword">for</span> i = 1:NroSpiketrains-1<br>                <span class="keyword">for</span> ii = i:NroSpiketrains<br>                    <span class="keyword">if</span> i ~= ii<br>                        pair{1} = obj.DataArray{2}{i};<br>                        pair{2} = obj.DataArray{2}{ii};<br>                        spikes = length(obj.DataArray{1}{i})+length(obj.DataArray{1}{ii})-4;<br>                        <span class="keyword">if</span> spikes &gt; 0<br>                            STS = SpikeTrainSet(pair,obj.timeStart,obj.timeEnd);<br>                            SPIKESM(i,ii) = STS.AdaptiveSPIKEsynchro(time1, time2, threshold);<br>                            SPIKESM(ii,i) = SPIKESM(i,ii);<br><br>                            [~,~,profile] = STS.AdaptiveSPIKEsynchroProfile(time1, time2, threshold);<br>                            SPIKEOM(i,ii) = sum(profile{1});<br>                            SPIKEOM(ii,i) = sum(profile{2});<br><br>                            normSPIKEOM(i,ii) = SPIKEOM(i,ii)/spikes;<br>                            normSPIKEOM(ii,i) = SPIKEOM(ii,i)/spikes;<br>                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>
</pre><h2>Auxiliary functions --------------------------------------------<a name="49"></a></h2><h2>Get function<a name="50"></a></h2><p>Gives a copy of the spike data contained in the spike train set</p><pre class="codeinput">        <span class="keyword">function</span>  DATA = giveDATA(obj)<br>            obj.HaveData(1);<br>            DATA = obj.DataArray;<br>        <span class="keyword">end</span>
</pre><h2>Threshold value extracted from the data<a name="51"></a></h2><p>returns the threshold value extracted from this dataset</p><pre class="codeinput">        <span class="keyword">function</span>  [THR, Mean] = giveTHR(obj)<br>            obj.HaveData(1);<br>            THR = obj.threshold;<br>            Mean = mean(obj.realISIs);<br>        <span class="keyword">end</span>
</pre><h2>Start and end of the data set<a name="52"></a></h2><p>returns an array with start and end times of the recording.</p><pre class="codeinput">        <span class="keyword">function</span>  [time1,time2] = giveTIMES(obj)<br>            obj.HaveData(1);<br>            time1 = obj.outputTimeShift(obj.timeStart);<br>            time2 = obj.outputTimeShift(obj.timeEnd);<br>        <span class="keyword">end</span>
</pre><h2>Plotting function<a name="53"></a></h2><p>Plots the spike trains to current axis</p><pre class="codeinput">        <span class="keyword">function</span>  plotSpikeTrainSet(obj,colour,width)<br>            obj.HaveData(1);<br>            <span class="keyword">if</span> nargin == 1<br>                colour = <span class="string">'k'</span>;<br>            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &lt; 3<br>                width = 1;<br>            <span class="keyword">end</span>

            beginning = obj.outputTimeShift(obj.timeStart);
            ending = obj.outputTimeShift(obj.timeEnd);
            hold <span class="string">on</span>;<br>            <span class="keyword">for</span> i = 1:length(obj.DataArray{2})<br><br>                SpikeTrain = obj.DataArray{2}{i};<br>                plotSpikeTrain(SpikeTrain,0.8,(length(obj.DataArray{2})+1-i)-0.5,colour,width)<br><br>            <span class="keyword">end</span>
            axis([beginning,ending,0,length(obj.DataArray{2})])
            set(gca,<span class="string">'ytick'</span>,[]);<br>        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% cSPIKE v 1.0 29.9.2016: Eero Satuvuori
% This is the main part of the cSPIKE. The object offers the basic
% functionality of graphical user interface SPIKY as a command line
% version. The main functions are implemented with MEX files and C++ 
% backends. Methods are based on the ISI-distance, the SPIKE-distance 
% and the SPIKE-synchronization by Thomas Kreuz et al. The class 
% contains data and methods for storing spike trains as a single set as 
% well as calculating the different distance measures.
%
%   To use SpikeTrainSet you need a C++ compiler for your Matlab. Some help
%   can be found in the following links
%   https://it.mathworks.com/help/matlab/matlab_external/what-you-need-to-build-mex-files.html
%   https://it.mathworks.com/support/compilers/R2016a/
%
%   SpikeTrainSet objects can be created without compiling MEX files, but
%   you can't call any distance measures without the appropriate MEX
%   compiled.
%
%   *** Important ***
%   Before you use the cSPIKE for the very first time on a computer you 
%   need to compile the MEX and C++ backends. To do so go to folder 
%   cSPIKEmex and run script MEX_compile.m. This may take few minutes.
%
%   Every time you call for MEX files(most functions of the SpikeTrainSet 
%   use them) the folder in which they are located need to be in your 
%   Matlab workspace. InitializecSPIKE-script will add it to your path. It 
%   needs to be called once every time after starting Matlab and any 
%   additional calls are not needed. This is not called by the SpikeTrainSet!
%   *****************
%   
%   The SpikeTrainSet implements the following functions
%
%   To create a spike train set object call the constructor:
%
%   spiketrains: A cell array with SpikeTrains{1} containing an
%                array of spike times [spike1 spike2 ...spikeN] for the 
%                first spike train and respectively for the other spike     
%                trains. The object accepts only spike data aligned as row 
%                vectors 
%   beginning: The start time of the recording
%   endgin: The end time of the recording
%
%   STS = SpikeTrainSet(spiketrains, beginning, ending )
%
%   Then you can call methods for the spike train set:
%
%   time1: Start time of the analysis interval.
%   time2: End time of the analysis interval. If not given or if 
%          time1 = time2 instantaneous dissimilarity value is given instead.
%   threshold: Threshold for the adaptive method. If not given the
%              threshold extracted from the data is used instead.
%   Profile: Profile object
%
%   STS.ISIdistance(time1, time2)
%   STS.ISIdistanceMatrix(time1, time2)
%   Profile = STS.ISIdistanceProfile(time1, time2)
%
%   STS.AdaptiveISIdistance(time1, time2, threshold)
%   STS.AdaptiveISIdistanceMatrix(time1, time2,threshold)
%   Profile = STS.AdaptiveISIdistanceProfile(time1, time2,threshold)
%
%   STS.SPIKEdistance(time1, time2)
%   STS.SPIKEdistanceMatrix(obj, time1, time2)
%   Profile = STS.SPIKEdistanceProfile(obj, time1, time2)
%
%   STS.AdaptiveSPIKEdistance(time1, time2, threshold)
%   STS.AdaptiveSPIKEdistanceMatrix(obj, time1, time2,threshold)
%   Profile = STS.AdaptiveSPIKEdistanceProfile(obj, time1, time2,threshold)
%   
%   STS.RateIndependentSPIKEdistance(time1, time2)
%   STS.AdaptiveRateIndependentSPIKEdistance(time1, time2, threshold)
%
%   STS.SPIKEsynchro(time1,time2)
%
%   STS.AdaptiveSPIKEsynchro(time1,time2,threshold)
%
%   SPIKESM: Spike synchronization matrix
%   SPIKEOM: Spike order matrix
%   normSPIKEOM: normalized spike order matrix
%
%   [SPIKESM,SPIKEOM,normSPIKEOM]= STS.SPIKESynchroMatrix(time1, time2)
%   [SPIKESM,SPIKEOM,normSPIKEOM] = STS.AdaptiveSPIKESynchroMatrix(time1, time2, threshold)
%
%   synchro: a cell array identical to spike train set but instead of spike
%            times it contains SPIKE-synchronization values of each spike
%   Sorder: a cell array identical to spike train set but instead of spike
%           times it contains SPIKE-order values of each spike
%   STOrder: a cell array identical to spike train set but instead of spike
%            times it contains spike-train-order values of each spike
%   
%   [synchro,Sorder,STOrder] = STS.SPIKEsynchroProfile(time1, time2)
%   [synchro,Sorder,STOrder] = STS.AdaptiveSPIKEsynchroProfile(time1, time2,threshold)
%
%   varargin: Each time moment is given as a separate parameter. Returns
%             the dissimilarity averaged over all time points.
%
%   STS.TriggeredISImatrix(varargin)
%   STS.TriggeredAdaptiveISImatrix(threshold, varargin)
%   STS.TriggeredSPIKEmatrix(varargin)
%   STS.TriggeredAdaptiveSPIKEmatrix(threshold, varargin)
%
%   varargin: Each pair of inputs defines a new interval over which the
%             distance is defined. A unique union of the intervals is
%             used when defining the intervals over which the average is
%             taken.
%
%   STS.AveragedISIdistanceMatrix(varargin)
%   STS.AveragedAdaptiveISIdistanceMatrix(threshold, varargin)
%   STS.AveragedSPIKEdistanceMatrix(varargin)
%   STS.AveragedAdaptiveSPIKEdistanceMatrix(threshold, varargin)
%
%   Auxiliary functions:
%   STS.SetData(spiketrains, beginning, ending )
%       Replaces the data in the object with new data
%   STS.giveDATA()
%       Gives the a copy of the data array of the object. Data{1} contains 
%       the edge corrected data and Data{2} the original spikes. 
%   STS.giveTHR()
%       Returns the threshold value obtained from the set
%   [time1,time2] = STS.giveTIMES()
%       Gives the beginning and the end of the recording
%   STS.plotSpikeTrainSet(colour,widith)
%       Plots the spike trains to current axis with colour and spike widith
%       given. Default colour is black.
%
%
% BSD license:
%
% Copyright (c) 2016, Eero Satuvuori
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions are met:
% * Redistributions of source code must retain the above copyright notice, 
% this list of conditions and the following disclaimer.
% * Redistributions in binary form must reproduce the above copyright notice, 
% this list of conditions and the following disclaimer in the documentation 
% and/or other materials provided with the distribution.
% * Neither the name of the author nor the names of its contributors may be 
% used to endorse or promote products derived from this software without 
% specific prior written permission.
%  
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
% ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY 
% DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
% AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
% TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

%% Class for enclosing spiketrains into one class and handling the set.
classdef SpikeTrainSet < handle
    
    
    properties (Access = private)
        
        % Internal datastores.
        DataArray;
        PooledArray;
        timeStart;
        timeEnd;
        threshold;
        timeShift;
        realISIs;
        
        % Internal accuracy used by the program. This is the maximum
        % accuracy used. Increasing the accuracy may lead to malfunctions.
        accuracy = 10^-12;
    end
    %% PRIVATE METHODS ****************************************************
    methods (Access = private)
        
        %% Checking data availability
        % Function is given a bool value if the information is crucial for
        % the calling function. In case it is an error is thrown. If it is 
        % not, just a bool value of 0 is returned if there is no data yet.
        function bool = HaveData(obj, crucial)
            
            % Returning 1 if there is data and 0 if there is not.
            if isempty(obj.DataArray)
                bool = 0;
                if crucial
                    error('No data available');
                end
            else
                bool = 1;
            end
            
        end
        %% Unique Union
        % Takes a set of intervals as a cell array so that each pair of two
        % values is an interval. The output is a unique union of the
        % intervals.
        function ReturnArray = UniqueUnion(obj, CellArray )
            starts = [];
            ends = [];
            for i = 1:2:length(CellArray)
                starts(end+1) = CellArray{i};
                ends(end+1) = CellArray{i+1};
            end
            
            UniqueArray = 0;
            
            while ~UniqueArray
                moves = 0;
                % Taking each first spike and if it is in an interval, move
                % it to the border of the interval.
                for i = 1:length(starts)
                    for ii = 1:length(starts)
                        
                        if (i ~= ii)
                            
                            if (starts(i) > starts(ii) && starts(i)< ends(ii))
                                
                                starts(i) = starts(ii);
                                moves = moves + 1;
                            end
                        end
                        
                    end
                end
                % Taking each last spike and doing the same.
                for i = 1:length(ends)
                    for ii = 1:length(ends)
                        
                        if (i ~= ii)
                            
                            if (ends(i) > starts(ii) && ends(i) < ends(ii))
                                
                                ends(i) = ends(ii);
                                moves = moves + 1;
                            end
                        end
                        
                    end
                end
                
                % If there were no moves this round, all the spikes are at
                % the edges of their intervals. There may be multiple same
                % intervals.
                if moves  == 0
                    
                    % now the array is unique. No need to continue.
                    UniqueArray = 1;
                    
                    % Taking each interval only once.
                    Ustarts = unique(starts);
                    Uends = unique(ends);
                    
                    % Since the intervals are in time order and unique,
                    % they will be in correct time order after unique
                    % command. The output is formed based on the intervals
                    ReturnArray = cell(0);
                    for i = 1:length(Ustarts)
                        
                        ReturnArray{end+1} = Ustarts(i);
                        ReturnArray{end+1} = Uends(i);
                    end
                end
            end
        end
        
        %% Checking that the DATA given is valid
        % Function checks the data and gives an error
        % if the data is not in a correct form
        function CheckData(obj,Data)
            
            if ~iscell(Data)
                error('Data is not a cell array');
            end
            if length(Data) == 1
                error('One spiketrain');
            end
            for i = 1:length(Data)
                
                if ndims(Data)~=2 || size(Data,2) ~= 1;
                    error('Data has incorrectly aligned cell array');
                end
                
                if ndims(Data{i}) ~=2 && (size(Data{i},1)||size(Data{i},2))
                    error('Data has too many dimensions');
                end
                
                if size(Data{i},1) ~= 1
                    if  ~isempty(Data{i})
                        error('Data has incorrectly aligned vectors');
                    end
                end
                
                if ~isnumeric(Data{i})
                    error('Data is not all numeric');
                end
            end
            
            
        end
        %% Cutting function
        % This function cuts the data so that spikes outside of boundaries
        % are removed.
        function Data = CutData(obj,Data, START, END)
            
            
            for i = 1:length(Data)
                inds = not(abs(sign(sign(START-obj.accuracy - Data{i})...
                       + sign(END+obj.accuracy - Data{i}))));
                Data{i} = Data{i}(inds);
            end
            
        end
        %%
        function Data = RoundData(obj, Data)
            
            dt = obj.accuracy;
            for i = 1:length(Data)
                Data{i} = round(Data{i}/dt)*dt;
            end
            
        end
        %% Check input times
        % Checking that times given are in correct order and within 
        % boundaries
        function CheckTime(obj,Time1,Time2)
            if Time1  > Time2
                error('Time interval boundaries incorrect');
            end
            
            if ~((Time1 >= obj.timeStart) && (Time2 <= obj.timeEnd))
                error('time interval not within data bounds');
            end
            
        end
        
        
        %% Correct the DATA Edges
        % Adds edge correction and makes sure that there are only 1 spike
        % at each time instant. Also rearranges the data into time series.
        
        function Corrected = EdgeCorrection(obj,Data,time1,time2)

            PooledISIs = [];
            Corrected = cell(1,length(Data))';
            for i = 1:length(Data)
                % 0 or 1 spikes cases
                if isempty(Data{i}) || length(Data{i}) == 1
                    if isempty(Data{i})
                        first = -(time2-time1)*1.2;
                        last = (time2-time1)*2.2;
                        Corrected{i} = [first obj.timeStart obj.timeEnd last];
                        Corrected{i} = unique(Corrected{i});
                        thisST = obj.timeEnd-obj.timeStart;
                    else
                        fullST = 0; %flag
                        first = obj.timeStart;
                        last = obj.timeEnd;
                        if Data{i} == first
                            first = -(time2-time1)*1.2;
                            thisST = obj.timeEnd-obj.timeStart;
                            fullST = 1;
                        end
                        if Data{i} == last
                            last = (time2-time1)*2.2;
                            thisST = obj.timeEnd-obj.timeStart;
                            fullST = 1;
                        end
                        
                        if ~fullST
                            thisST = [last-Data{i} Data{i}-first];
                        end
                        
                        Corrected{i} = [first Data{i} last];
                        Corrected{i} = unique(Corrected{i});
                    end
                    
                else
                    %The rest
                    thisST = Data{i}(2:end) - Data{i}(1:end-1);
                    if(Data{i}(1) ~= time1)
                        first = Data{i}(1) - max( Data{i}(2)-Data{i}(1), Data{i}(1) - obj.timeStart );
                        thisST = [thisST Data{i}(1)-first];
                    else
                        % In case the first spike is at the border it is
                        % not treated as auxiliary spike. For calculation
                        % the next spike does not matter so we add an
                        % "auxiliary" spike very far from the dataset to
                        % mark that the border is a real one.
                        first = -(time2-time1)*1.2;
                    end
                    if(Data{i}(end)~= time2)
                        last = Data{i}(end) + max( Data{i}(end)-Data{i}(end-1),obj.timeEnd - Data{i}(end));
                        thisST = [thisST last-Data{i}(end)];
                    else
                        % Same for the other end.
                        last = (time2-time1)*2.2;
                    end
                    
                    
                    
                    Corrected{i} = [first last Data{i}];
                    
                    % At the end making sure that each dataset has only one
                    % spike at each time instant and that they are in time 
                    % order
                    Corrected{i} = unique(Corrected{i});
                end
                PooledISIs = [PooledISIs thisST];
            end
            
            if(isempty (PooledISIs))
                obj.threshold = 0;
            else
                obj.threshold = sqrt(mean(PooledISIs.^2));
            end
            obj.realISIs = PooledISIs;
            
        end
        
        %% Form pooled spiketrain of all spiketrains
        % Pools all spiketrains into one. Uses unique, so that multiple
        % spikes at same times are filtered out.
        function Pooled = Pool(obj , Data)
            
            Pooled = [];
            for i = 1:length(Data)
                Pooled = [Pooled Data{i}];
            end
            Pooled = unique(Pooled);
            
        end
        %% Time shift functions.
        % These functions take care of the difference between "real" times
        % and internal times. The object computes using positive spiketimes
        % and in case the recording begins at negative times, all data is
        % shifted so that the recording begins from 0 internally. For
        % output the times are again shifted back to original.
        function  [time1,time2,Data] = CreateTimeShift(obj,time1,time2,Data)
            
            obj.timeShift = time1;
            time1 = time1-obj.timeShift;
            time2 = time2-obj.timeShift;
            for i = 1:length(Data)
                Data{i}=Data{i}-obj.timeShift;
            end
            
        end
        
        function  [time] = InputTimeShift(obj,time)
            
            time = time-obj.timeShift;
            
        end
        
        
        function  [time] = outputTimeShift(obj,time)
            
            time = time+obj.timeShift;
            
        end
        
        
    end
    %% PUBLIC METHODS *****************************************************
    methods (Access = public)
        %% Constructor
        % Builds a spiketrain set with the spiketrains given and beginning
        % and end times.
        function obj = SpikeTrainSet(spiketrains, beginning, ending )
            obj.timeShift = 0;
            obj.SetData(spiketrains, beginning, ending );
            
        end
        
        %% Setting data
        % Function sets data to the classes own variables. Calls
        % appropriate checking functions to input. Data is only accepted
        % in a single cell array containing spiketrains. If called to a
        % spiketrain set that has already been set, the user is asked for
        % input if it is to be replaced.
        function SetData(obj, Data, time1, time2)
            Data = Data';
            % checking that the data is in correct form.
            obj.CheckData(Data);
            %Rounding data to 12 digits accuracy
            Data = obj.RoundData(Data);
            % Cutting spikes outside of interval
            Data = obj.CutData(Data, time1, time2);
            % If there was no data, add the data
            if obj.HaveData(0)
                
                %presetting answer variable into not n or y
                answer = 'h';
                % If there was data, ask if the data is to be replaced
                while answer ~= 'y' && answer ~= 'Y' && answer ~= 'n' && answer ~= 'N'
                    answer = input('Do you want to replace the data?(y/n)','s');
                end
                %
                if answer == 'y' || answer ~= 'Y'
                    
                    % Swiping old arrays clean
                    obj.DataArray = [];
                    obj.PooledArray= [];
                    
                    % Adding new values to the array
                    obj.DataArray{2} = Data;
                    [time1,time2,Data] = obj.CreateTimeShift(time1,time2,Data);
                    obj.timeStart = time1;
                    obj.timeEnd = time2;
                    obj.DataArray{1} = obj.EdgeCorrection(Data);
                    obj.PooledArray = obj.Pool(Data);
                    
                end
            else
                % Setting the arrays for the first time
                obj.DataArray{2} = Data;
                [time1,time2,Data] = obj.CreateTimeShift(time1,time2,Data);
                obj.timeStart = time1;
                obj.timeEnd = time2;
                obj.DataArray{1} = obj.EdgeCorrection(Data,time1,time2);
                obj.PooledArray = obj.Pool(Data);
                
            end
            
        end
        
        %% ISI METHODS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % The methods in this section are applying ISI distance measure to
        % the data. The section also contains Adaptive extension.
        
        %% ISI-distance for interval/point
        % Calculates ISI distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, return dissimilarity of the
        % spiketrains at that time instant.
        function  ISId = ISIdistance(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            ISId = AdaptiveISIdistance(obj, time1, time2, 0);
            
        end
        %% Adaptive ISI-distance for interval/point
        % Calculates SPIKE distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, return dissimilarity of the
        % spiketrains at that time instant.
        function  ISId = AdaptiveISIdistance(obj, time1, time2, threshold)
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin == 2
                time2 = time1;
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            if(time1 == time2)
                ISId = mexAdaptiveISIDistance(obj.DataArray{1},threshold,time1);
            else
                ISId = mexAdaptiveISIDistance(obj.DataArray{1},threshold,time1, time2);
            end
        end
        %% ISI-distance/dissimilarity matrix
        % Returns the distance matrix of the spike trains averaged over
        % time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs.
        function  ISIdM = ISIdistanceMatrix(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            ISIdM = AdaptiveISIdistanceMatrix(obj, time1, time2, 0);
        end
        %% Adaptive ISI-distance/dissimilarity matrix
        % Returns the adaptive distance matrix of the spike trains averaged 
        % over time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs. Threshold can be given as a parameter. If not given the
        % one extracted from the data is used.
        function  ISIdM = AdaptiveISIdistanceMatrix(obj, time1, time2,threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            
            if nargin == 2
                time2 = time1;
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            ISIdM = mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold ,time1, time2);
            
        end
        %% Triggered ISI-dissimilarity matrix
        % Returns the averaged dissimilarity matrix of the spike trains
        % averaged over time instants defined in inputs. Each instant is 
        % given as new variables: (1,2,5,6) being average over time 
        % instants 1,2,5 and 6.
        function  ISIdM = TriggeredISImatrix(obj, varargin)
            
            if nargin < 3
                error('Not enough input arguments');
            end
            ISIdM = TriggeredAdaptiveISImatrix(obj,0, varargin);
        end
        
        %% Triggered Adaptive ISI-dissimilarity matrix
        % Returns the averaged dissimilarity matrix of the spike trains
        % averaged over time instants defined in inputs. Each instant is 
        % given as new variables: (1,2,5,6) being average over time 
        % instants 1,2,5 and 6. If a negative threshold value is given the 
        % data exctracted threshold is used.
        function  ISIdM = TriggeredAdaptiveISImatrix(obj,threshold, varargin)
            if threshold < 0
                threshold = obj.threshold;
            end
            if nargin < 4
                error('Not enough input arguments');
            end
            
            obj.HaveData(1);
            time = obj.InputTimeShift(varargin{1});
            obj.CheckTime(time,time);
            
            ISIdM = mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold,time, time);
            for i = 2:(nargin-1)
                time = obj.InputTimeShift(varargin{i});
                obj.CheckTime(time,time);
                ISIdM = ISIdM + mexAdaptiveISIDistanceMatrix(obj.DataArray{1},threshold,time, time);
            end
            
            ISIdM = ISIdM./(nargin-2);
        end
        
        %% Averaged ISI-distance matrix
        % Returns the distance matrix of the spike trains averaged over
        % time intervals defined as pairs of inputs. The inputs must be in
        % pairs. If the intervals overlap, the average is computed over
        % unique union of the intervals. Input is given as new pairs of 
        % variables: (1,2,5,6) being average over time intervals [1,2] and 
        % [5,6].
        function  ISIdM = AveragedISIdistanceMatrix(obj, varargin)
            if nargin < 3
                error('Not enough input arguments');
            end
            if mod(nargin,2) == 0;
                error('Not a paired number of time points');
            end
            
            ISIdM = AveragedAdaptiveISIdistanceMatrix(obj,0, varargin);
            
        end
        
        %% Averaged Adaptive ISI-distance matrix
        % Returns the distance matrix of the spike trains averaged over
        % time intervals defined as pairs of inputs. The inputs must be in
        % pairs. If the intervals overlap, the average is computed over
        % unique union of the intervals. Input is given as new pairs of 
        % variables: (1,2,5,6) being average over time intervals [1,2] and 
        % [5,6]. Threshold can be given as a parameter. If a negative
        % threshold value is given the data exctracted threshold is used.
        function  ISIdM = AveragedAdaptiveISIdistanceMatrix(obj,threshold, varargin)
            if threshold < 0
                threshold = obj.threshold;
            end
            if nargin < 4
                error('Not enough input arguments');
            end
            if mod(nargin,2) == 1;
                error('Not a paired number of time points');
            end
            
            obj.HaveData(1);
            
            % Forming unique union of input
            Timeslices = obj.UniqueUnion(varargin);
            
            time1 = Timeslices{1};
            time2 = Timeslices{2};
            time1 = obj.InputTimeShift(time1);
            time2 = obj.InputTimeShift(time2);
            obj.CheckTime(time1,time2);
            TotalTime = time2-time1;
            ISIdM = (time2-time1)*mexISIistanceMatrix(obj.DataArray{1},threshold,time1, time2);
            
            for i = 3:2:length(Timeslices)
                
                time1 = Timeslices{i};
                time2 = Timeslices{i+1};
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
                obj.CheckTime(time1,time2);
                ISIdM = ISIdM + (time2-time1)*mexISIistanceMatrix(obj.DataArray{1},threshold,time1, time2);
                TotalTime = TotalTime + (time2-time1);
            end
            
            % averaging over time. Each matrix is weighted
            ISIdM = ISIdM./TotalTime;
        end
        
        %% ISI-distance profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting. See object Profile for more information.
        function  ISIp = ISIdistanceProfile(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            ISIp = AdaptiveISIdistanceProfile(obj, time1, time2,0);
        end
        %% Adaptive ISI-distance profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting. See object Profile for more information.
        function  ISIp = AdaptiveISIdistanceProfile(obj, time1, time2,threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            internalProfile = mexAdaptiveISIDistanceProfile(obj.DataArray{1},threshold,time1, time2);
            internalProfile(2,:) = obj.outputTimeShift(internalProfile(2,:));
            ISIp = Profile(internalProfile);
            
        end
        %% SPIKE METHODS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % The methods in this section are applying the SPIKE-distance 
        % measure to the data. The section also contains Adaptive and rate 
        % intedependent extensions. 
        
        %% SPIKE-distance for interval/point
        % Calculates SPIKE distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, return dissimilarity of the
        % spiketrains at that time instant.
        function  SPIKEd = SPIKEdistance(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            SPIKEd = AdaptiveSPIKEdistance(obj, time1, time2, 0);
        end
        %% Adaptive SPIKE-distance for interval/point
        % Calculates SPIKE distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, return dissimilarity of the
        % spiketrains at that time instant.
        function  SPIKEd = AdaptiveSPIKEdistance(obj, time1, time2, threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin == 2
                time2 = time1;
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            if(time1 == time2)
                SPIKEd = mexAdaptiveSPIKEDistance(obj.DataArray{1},threshold,time1);
            else
                SPIKEd = mexAdaptiveSPIKEDistance(obj.DataArray{1},threshold,time1, time2);
            end
        end
        
        %% Rate independent SPIKE distance for interval/point
        % Calculates SPIKE distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, returns dissimilarity of the
        % spiketrains at that time instant. 
        
        
        function  SPIKEd = RateIndependentSPIKEdistance(obj, time1, time2)
            
            SPIKEd = AdaptiveRateIndependentSPIKEdistance(obj, time1, time2, 0);
            
        end
        %% Adaptive Rate independent SPIKE distance for interval/point
        % Calculates SPIKE distance for given interval between time1 and
        % time2. time1 < time2. If no input times are given return value
        % for whole data set interval that is defined. If only one time is
        % given or both are the same, returns dissimilarity of the
        % spiketrains at that time instant. This will use
        % the predetermined threshold. If you then want to set threshold
        % yourself give it as third parameter.        
        
        function  SPIKEd = AdaptiveRateIndependentSPIKEdistance(obj, time1, time2, threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            if(time1 == time2)
                SPIKEd = mexAdaptiveRateIndependentSPIKEDistance(obj.DataArray{1},threshold,time1);
            else
                SPIKEd = mexAdaptiveRateIndependentSPIKEDistance(obj.DataArray{1},threshold,time1, time2);
            end
        end
        %% SPIKE distance/dissimilarity matrix
        % Returns the distance matrix of the spike trains averaged over
        % time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs.
        function  SPIKEdM = SPIKEdistanceMatrix(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            SPIKEdM = AdaptiveSPIKEdistanceMatrix(obj, time1, time2, 0);
        end
        
        %% Adaptive SPIKE distance/dissimilarity matrix
        % Returns the distance matrix of the spike trains averaged over
        % time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs.
        function  SPIKEdM = AdaptiveSPIKEdistanceMatrix(obj, time1, time2,threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin == 2
                time2 = time1;
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            SPIKEdM = mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);
            
        end
        
        %% Triggered SPIKE-dissimilarity matrix
        % Returns the averaged dissimilarity matrix of the spike trains
        % averaged over time instants defined in inputs. Each instant is 
        % given as new variables: (1,2,5,6) being average over time 
        % instants 1,2,5 and 6.
        function  SPIKEdM = TriggeredSPIKEmatrix(obj, varargin)
            
            if nargin < 3
                error('Not enough input arguments');
            end
            SPIKEdM = TriggeredAdaptiveSPIKEmatrix(obj,0, varargin);
            
        end
        
        %% Triggered Adaptive SPIKE-dissimilarity matrix
        % Returns the averaged dissimilarity matrix of the spike trains
        % averaged over time instants defined in inputs. Each instant is 
        % given as new variables: (1,2,5,6) being average over time 
        % instants 1,2,5 and 6. If a negative threshold value is given the 
        % data exctracted threshold is used.
        
        function  SPIKEdM = TriggeredAdaptiveSPIKEmatrix(obj,threshold, varargin)
            if threshold < 0
                threshold = obj.threshold;
            end
            if nargin < 4
                error('Not enough input arguments');
            end
            
            obj.HaveData(1);
            time = obj.InputTimeShift(varargin{1});
            obj.CheckTime(time,time);
            
            SPIKEdM = mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time, time);
            for i = 2:(nargin-1)
                time = obj.InputTimeShift(varargin{i});
                obj.CheckTime(time,time);
                SPIKEdM = SPIKEdM + mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time, time);
            end
            
            SPIKEdM = SPIKEdM./(nargin-1);
        end
        
        %% Averaged SPIKE-distance matrix
        % Returns the distance matrix of the spike trains averaged over
        % time intervals defined as pairs of inputs. The inputs must be in
        % pairs. If the intervals overlap, the average is computed over
        % unique union of the intervals. Input is given as new pairs of 
        % variables: (1,2,5,6) being average over time intervals [1,2] and 
        % [5,6].
        function  SPIKEdM = AveragedSPIKEdistanceMatrix(obj, varargin)
            
            if nargin < 3
                error('Not enough input arguments');
            end
            if mod(nargin,2) == 0;
                error('Not a paired number of time points');
            end
            SPIKEdM = AveragedAdaptiveSPIKEdistanceMatrix(obj, 0, varargin);
        end
        
        %% Averaged Adaptive SPIKE-distance matrix
        % Returns the distance matrix of the spike trains averaged over
        % time intervals defined as pairs of inputs. The inputs must be in
        % pairs. If the intervals overlap, the average is computed over
        % unique union of the intervals. Input is given as new pairs of 
        % variables: (1,2,5,6) being average over time intervals [1,2] and 
        % [5,6]. Threshold can be given as a parameter. If a negative
        % threshold value is given the data exctracted threshold is used.
        
        
        function  SPIKEdM = AveragedAdaptiveSPIKEdistanceMatrix(obj, threshold, varargin)
            if threshold < 0
                threshold = obj.threshold;
            end
            if nargin < 4
                error('Not enough input arguments');
            end
            if mod(nargin,2) == 1;
                error('Not a paired number of time points');
            end
            
            obj.HaveData(1);
            
            % Forming unique union of input
            Timeslices = obj.UniqueUnion(varargin);
            
            time1 = Timeslices{1};
            time2 = Timeslices{2};
            time1 = obj.InputTimeShift(time1);
            time2 = obj.InputTimeShift(time2);
            obj.CheckTime(time1,time2);
            TotalTime = time2-time1;
            SPIKEdM = (time2-time1)*mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);
            
            for i = 3:2:length(Timeslices)
                
                time1 = Timeslices{i};
                time2 = Timeslices{i+1};
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
                obj.CheckTime(time1,time2);
                SPIKEdM = SPIKEdM + (time2-time1)*mexAdaptiveSPIKEDistanceMatrix(obj.DataArray{1},threshold,time1, time2);
                TotalTime = TotalTime + (time2-time1);
            end
            
            % averaging over time. Each matrix is weighted
            SPIKEdM = SPIKEdM./TotalTime;
        end
        
        %% SPIKE-distance profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting.
        function  SPIKEp = SPIKEdistanceProfile(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            SPIKEp = AdaptiveSPIKEdistanceProfile(obj, time1, time2, 0);
            
        end
        %% Adaptive SPIKE-distance profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting.
        function  SPIKEp = AdaptiveSPIKEdistanceProfile(obj, time1, time2,threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            internalProfile = mexAdaptiveSPIKEDistanceProfile(obj.DataArray{1},threshold,time1, time2);
            internalProfile(2,:) = obj.outputTimeShift(internalProfile(2,:));
            SPIKEp = Profile(internalProfile);
            
        end
        
        
        %% SPIKE-Synchronization METHODS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % The methods in this section are applying SPIKE-synchronization
        % measure to the data
        
        %% SPIKE-Synchronization 
        % This function returns the value of the method from the given
        % interval given in the input.
        function  synchro = SPIKEsynchro(obj,time1,time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            synchro = AdaptiveSPIKEsynchro(obj,time1,time2, 0);
        end
        
        %% Adaptive SPIKE-synchronization 
        % This function returns the value of the method from the given
        % interval given in the input. If no threshold value is given the
        % data exctracted value is used.
        function  synchro = AdaptiveSPIKEsynchro(obj,time1,time2,threshold)
            obj.HaveData(1);
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            synchro = mexAdaptiveSPIKESynchro(obj.DataArray{1},threshold/2,obj.timeStart,obj.timeEnd,time1,time2);
            
        end
        %% SPIKE-synchronization profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting.
        function  [synchro, Sorder, STOrder] = SPIKEsynchroProfile(obj, time1, time2)
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            [synchro, Sorder, STOrder] = AdaptiveSPIKEsynchroProfile(obj, time1, time2, 0);
            
        end
        %% Adaptive SPIKE-synchronization profile
        % Forms a profile between times 1 and 2. The output is a Matlab
        % class Profile, which contains the profile and can even perform a
        % simple plotting.
        function  [synchro, Sorder, STOrder] = AdaptiveSPIKEsynchroProfile(obj, time1, time2,threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            % Change later into a real profile
            [synchro, Sorder, STOrder] = mexAdaptiveSPIKESynchroProfile(obj.DataArray{1},threshold/2,obj.timeStart,obj.timeEnd,time1, time2);
            
        end
        
        %% SPIKE-synchronization matrix
        % Returns the distance matrix of the spike trains averaged over
        % time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs.
        
        function  [SPIKESM,SPIKEOM,normSPIKEOM] = SPIKESynchroMatrix(obj, time1, time2)
            
            if nargin == 1
                time1 = outputTimeShift(obj,obj.timeStart);
                time2 = outputTimeShift(obj,obj.timeEnd);
            end
            if nargin == 2
                time2 = time1;
            end
            
            [SPIKESM,SPIKEOM,normSPIKEOM] = AdaptiveSPIKESynchroMatrix(obj, time1, time2, 0);
            
        end
        
        %% Adaptive SPIKE-synchronization matrix
        % Returns the distance matrix of the spike trains averaged over
        % time interval defined by time 1 and time 2. If not given,
        % averaged over whole interval. If given only one time or the same
        % one twice, the returned matrix is dissimilarity between all
        % pairs. If no threshold value is given thedata exctracted value 
        % is used.
        function  [SPIKESM,SPIKEOM,normSPIKEOM] = AdaptiveSPIKESynchroMatrix(obj, time1, time2, threshold)
            
            if nargin == 1
                time1 = obj.timeStart;
                time2 = obj.timeEnd;
            else
                time1 = obj.InputTimeShift(time1);
                time2 = obj.InputTimeShift(time2);
            end
            if nargin == 2
                time2 = time1;
            end
            if nargin < 4
                threshold = obj.threshold;
            end
            obj.HaveData(1);
            obj.CheckTime(time1,time2);
            
            NroSpiketrains = length(obj.DataArray{1});
            SPIKESM = ones(NroSpiketrains);
            SPIKEOM = zeros(NroSpiketrains);
            normSPIKEOM = zeros(NroSpiketrains);
            for i = 1:NroSpiketrains-1
                for ii = i:NroSpiketrains
                    if i ~= ii
                        pair{1} = obj.DataArray{2}{i};
                        pair{2} = obj.DataArray{2}{ii};
                        spikes = length(obj.DataArray{1}{i})+length(obj.DataArray{1}{ii})-4;
                        if spikes > 0
                            STS = SpikeTrainSet(pair,obj.timeStart,obj.timeEnd);
                            SPIKESM(i,ii) = STS.AdaptiveSPIKEsynchro(time1, time2, threshold);
                            SPIKESM(ii,i) = SPIKESM(i,ii);
                            
                            [~,~,profile] = STS.AdaptiveSPIKEsynchroProfile(time1, time2, threshold);
                            SPIKEOM(i,ii) = sum(profile{1});
                            SPIKEOM(ii,i) = sum(profile{2});
                            
                            normSPIKEOM(i,ii) = SPIKEOM(i,ii)/spikes;
                            normSPIKEOM(ii,i) = SPIKEOM(ii,i)/spikes;
                        end
                    end
                end
            end
            
        end
        
        %% Auxiliary functions REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        
        %% Get function
        % Gives a copy of the spike data contained in the spike train set
        function  DATA = giveDATA(obj)
            obj.HaveData(1);
            DATA = obj.DataArray;
        end
        %% Threshold value extracted from the data
        % returns the threshold value extracted from this dataset
        function  [THR, Mean] = giveTHR(obj)
            obj.HaveData(1);
            THR = obj.threshold;
            Mean = mean(obj.realISIs);
        end

        %% Start and end of the data set
        % returns an array with start and end times of the recording.
        function  [time1,time2] = giveTIMES(obj)
            obj.HaveData(1);
            time1 = obj.outputTimeShift(obj.timeStart);
            time2 = obj.outputTimeShift(obj.timeEnd);
        end
        
        %% Plotting function
        % Plots the spike trains to current axis
        function  plotSpikeTrainSet(obj,colour,width)
            obj.HaveData(1);
            if nargin == 1
                colour = 'k';
            end
            if nargin < 3
                width = 1;
            end
            
            beginning = obj.outputTimeShift(obj.timeStart);
            ending = obj.outputTimeShift(obj.timeEnd);
            hold on;
            for i = 1:length(obj.DataArray{2})
                
                SpikeTrain = obj.DataArray{2}{i};
                plotSpikeTrain(SpikeTrain,0.8,(length(obj.DataArray{2})+1-i)-0.5,colour,width)
                
            end
            axis([beginning,ending,0,length(obj.DataArray{2})])
            set(gca,'ytick',[]);
        end
        
        
    end
  
end


##### SOURCE END #####
--></body></html>